import React, { PropsWithChildren, CSSProperties, FunctionComponent, ReactNode, Ref } from 'react';

type CustomElement<
  P,
  E extends HTMLElement = HTMLElement
> = React.DetailedHTMLProps<React.HTMLAttributes<E>, E> & P;

declare module 'react' {
  namespace JSX {
    interface IntrinsicElements {
      'gmp-advanced-marker': CustomElement<
        {
          position?: google.maps.LatLngLiteral | string | null;
          title?: string | null;
          anchorLeft?: string | null;
          anchorTop?: string | null;
          collisionBehavior?: google.maps.CollisionBehavior | null;
          gmpClickable?: boolean | null;
          gmpDraggable?: boolean | null;
          map?: google.maps.Map | null;
          zIndex?: number | null;

          /** @deprecated */
          readonly element?: HTMLElement;

          /** @deprecated */
          content?: string;

          'gmp-clickable'?: boolean;
          'anchor-left'?: string;
          'anchor-top'?: string;
        },
        google.maps.marker.AdvancedMarkerElement
      >;

      'gmp-pin': CustomElement<
        {
          background?: string | null;
          borderColor?: string | null;
          glyphColor?: string | null;
          glyphSrc?: URL | string | null;
          glyphText?: string | null;

          scale?: number | string;
          readonly element?: HTMLElement;

          /** @deprecated */
          glyph?: string | Element | URL | null;

          'border-color'?: string;
          'glyph-color'?: string;
          'glyph-src'?: string;
          'glyph-text'?: string;
        },
        google.maps.marker.PinElement
      >;
    }
  }
}

type Map3DProps = {
  bounds?:
    | google.maps.LatLngBounds
    | google.maps.LatLngBoundsLiteral
    | string
    | null;
  center?:
    | google.maps.LatLngAltitude
    | google.maps.LatLngAltitudeLiteral
    | string
    | null;
  heading?: number | string | null;
  mode?: google.maps.maps3d.MapMode | string | null;
  range?: number | string | null;
  roll?: number | string | null;
  tilt?: number | string | null;

  /** @deprecated */
  defaultUIDisabled?: boolean | null;
  defaultUIHidden?: boolean | null;
  maxAltitude?: number | null;
  maxHeading?: number | null;
  maxTilt?: number | null;
  minAltitude?: number | null;
  minHeading?: number | null;
  minTilt?: number | null;

  /** @deprecated */
  'default-ui-disabled'?: boolean | string;
  'default-ui-hidden'?: boolean | string;
  'max-altitude'?: string;
  'max-heading'?: string;
  'max-tilt'?: string;
  'min-altitude'?: string;
  'min-heading'?: string;
  'min-tilt'?: string;
};

type Marker3DProps = {
  extruded?: boolean | string | null;
  label?: string | null;
  position?:
    | google.maps.LatLngLiteral
    | google.maps.LatLngAltitudeLiteral
    | string
    | null;

  altitudeMode?: google.maps.maps3d.AltitudeMode | null;
  collisionBehavior?: google.maps.CollisionBehavior | null;
  drawsWhenOccluded?: boolean | null;
  sizePreserved?: boolean | null;
  zIndex?: number | null;

  'altitude-mode'?: string;
  'collision-behavior'?: string;
  'draws-when-occluded'?: boolean | string;
  'size-preserved'?: boolean | string;
  'z-index'?: string;
};

type Model3DProps = {
  orientation?:
    | google.maps.Orientation3D
    | google.maps.Orientation3DLiteral
    | string
    | null;
  position?:
    | google.maps.LatLngLiteral
    | google.maps.LatLngAltitude
    | google.maps.LatLngAltitudeLiteral
    | string
    | null;
  scale?:
    | number
    | google.maps.Vector3D
    | google.maps.Vector3DLiteral
    | string
    | null;
  src?: string | URL | null;

  altitudeMode?: google.maps.maps3d.AltitudeMode | null;

  'altitude-mode'?: string;
};

type Polyline3DProps = {
  extruded?: boolean | string | null;
  geodesic?: boolean | string | null;
  path?: string | null;

  altitudeMode?: google.maps.maps3d.AltitudeMode | null;
  coordinates?: Iterable<
    | google.maps.LatLngAltitude
    | google.maps.LatLngAltitudeLiteral
    | google.maps.LatLngLiteral
  > | null;
  drawsOccludedSegments?: boolean | null;
  outerColor?: string | null;
  outerWidth?: number | null;
  strokeColor?: string | null;
  strokeWidth?: number | null;
  zIndex?: number | null;

  'altitude-mode'?: string;
  'draws-occluded-segments'?: boolean | string;
  'outer-color'?: string;
  'outer-width'?: string;
  'stroke-color'?: string;
  'stroke-width'?: string;
  'z-index'?: string;
};

type Polygon3DProps = {
  extruded?: boolean | string | null;
  geodesic?: boolean | string | null;
  path?: string | null;

  altitudeMode?: google.maps.maps3d.AltitudeMode | null;
  drawsOccludedSegments?: boolean | null;
  fillColor?: string | null;
  innerCoordinates?: Iterable<
    | Iterable<google.maps.LatLngAltitude | google.maps.LatLngAltitudeLiteral>
    | Iterable<google.maps.LatLngLiteral>
  > | null;
  outerCoordinates?: Iterable<
    | google.maps.LatLngAltitude
    | google.maps.LatLngAltitudeLiteral
    | google.maps.LatLngLiteral
  > | null;
  strokeColor?: string | null;
  strokeWidth?: number | null;
  zIndex?: number | null;

  'altitude-mode'?: string;
  'draws-occluded-segments'?: boolean | string;
  'fill-color'?: string;
  'inner-paths'?: string;
  'stroke-color'?: string;
  'stroke-width'?: string;
  'z-index'?: string;
};

type PopoverProps = {
  open?: boolean | string | null;

  altitudeMode?: google.maps.maps3d.AltitudeMode | null;
  lightDismissDisabled?: boolean | null;
  positionAnchor?:
    | google.maps.LatLngLiteral
    | google.maps.LatLngAltitudeLiteral
    | google.maps.maps3d.Marker3DInteractiveElement
    | string
    | null;

  'altitude-mode'?: string;
  'light-dismiss-disabled'?: boolean | string;
  'position-anchor'?: string;
};

declare module 'react' {
  namespace JSX {
    interface IntrinsicElements {
      'gmp-map-3d': CustomElement<Map3DProps, google.maps.Map3DElement>;

      'gmp-marker-3d': CustomElement<
        Marker3DProps,
        google.maps.Marker3DElement
      >;

      'gmp-marker-3d-interactive': CustomElement<
        Marker3DProps & {
          title?: string;
          gmpPopoverTargetElement?: google.maps.maps3d.PopoverElement | null;
          'gmp-popover-target-element'?: string;
        },
        google.maps.Marker3DInteractiveElement
      >;

      'gmp-model-3d': CustomElement<Model3DProps, google.maps.Model3DElement>;

      'gmp-model-3d-interactive': CustomElement<
        Model3DProps,
        google.maps.Model3DInteractiveElement
      >;

      'gmp-polyline-3d': CustomElement<
        Polyline3DProps,
        google.maps.Polyline3DElement
      >;

      'gmp-polyline-3d-interactive': CustomElement<
        Polyline3DProps,
        google.maps.Polyline3DInteractiveElement
      >;

      'gmp-polygon-3d': CustomElement<
        Polygon3DProps,
        google.maps.Polygon3DElement
      >;

      'gmp-polygon-3d-interactive': CustomElement<
        Polygon3DProps,
        google.maps.Polygon3DInteractiveElement
      >;

      'gmp-popover': CustomElement<PopoverProps, google.maps.PopoverElement>;
    }
  }
}

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
type NoAttributes = {};
type NoChildren = {children?: never};

declare module 'react' {
  namespace JSX {
    interface IntrinsicElements {
      // ================================
      // ======== Places Widgets ========
      // ================================

      'gmp-place-autocomplete': CustomElement<
        // FIXME: the PlaceAutocompleteElementOptions type in @types/google.maps isn't the one defined in the docs.
        //   https://developers.google.com/maps/documentation/javascript/reference/places-widget
        {
          includedPrimaryTypes?: string[] | null;
          includedRegionCodes?: string[] | null;
          locationBias?: google.maps.places.LocationBias | null;
          locationRestriction?: google.maps.places.LocationRestriction | null;
          name?: string | null;
          origin?:
            | google.maps.LatLng
            | google.maps.LatLngLiteral
            | google.maps.LatLngAltitude
            | google.maps.LatLngAltitudeLiteral
            | string
            | null;
          requestedLanguage?: string | null;
          requestedRegion?: string | null;
          unitSystem?: google.maps.UnitSystem | null;

          // html-attribute versions for props
          'included-primary-types'?: string;
          'included-region-codes'?: string;
          'requested-language'?: string;
          'requested-region'?: string;
          'unit-system'?: string;

          // emits 'gmp-error' and 'gmp-select'
        },
        google.maps.places.PlaceAutocompleteElement
      >;

      // FIXME: this doesn't exist in types, not sure of its relevance. In types, it seems
      //   identical to the gmp-place-autocomplete. See
      //   https://developers.google.com/maps/documentation/javascript/reference/places-widget
      'gmp-basic-place-autocomplete': JSX.IntrinsicElements['gmp-place-autocomplete'];

      // alpha only
      'gmp-place-contextual': CustomElement<
        google.maps.places.PlaceContextualElementOptions & {
          // html-attribute versions
          'context-token'?: string;
        },
        google.maps.places.PlaceContextualElement
      >;

      // alpha only
      'gmp-place-contextual-list-config': CustomElement<
        {
          layout?: google.maps.places.PlaceContextualListLayout | string | null;
          mapHidden?: boolean | null;

          'map-hidden'?: string | boolean;
        },
        google.maps.places.PlaceContextualListConfigElement
      >;

      'gmp-place-details': CustomElement<
        {readonly place?: google.maps.places.Place | null},
        google.maps.places.PlaceDetailsElement

        // emits 'gmp-error' and 'gmp-load' events
      >;

      'gmp-place-details-compact': CustomElement<
        {
          readonly place?: google.maps.places.Place | null;
          orientation?:
            | google.maps.places.PlaceDetailsOrientation
            | string
            | null;
          truncationPreferred?: boolean | null;

          // html-attribute versions
          'truncation-preferred'?: string | boolean;
        },
        google.maps.places.PlaceDetailsCompactElement
      >;

      'gmp-place-details-place-request': CustomElement<
        {
          place?: google.maps.places.Place | string | null;
        },
        google.maps.places.PlaceDetailsPlaceRequestElement
      >;

      'gmp-place-details-location-request': CustomElement<
        {
          location?:
            | google.maps.LatLng
            | google.maps.LatLngLiteral
            | google.maps.LatLngAltitude
            | google.maps.LatLngAltitudeLiteral
            | string
            | null;
        },
        google.maps.places.PlaceDetailsLocationRequestElement
      >;

      'gmp-place-search': CustomElement<
        {
          attributionPosition?: google.maps.places.PlaceSearchAttributionPosition | null;
          orientation?:
            | google.maps.places.PlaceSearchOrientation
            | string
            | null;
          places?: google.maps.places.Place[] | null;
          selectable?: boolean | null;
          truncationPreferred?: boolean | null;

          'attribution-position'?: string;
          'truncation-preferred'?: string | boolean;

          // emits 'gmp-error', 'gmp-load' and 'gmp-select'
        },
        google.maps.places.PlaceSearchElement
      >;

      'gmp-place-nearby-search-request': CustomElement<
        {
          excludedPrimaryTypes?: string[] | null;
          excludedTypes?: string[] | null;
          includedPrimaryTypes?: string[] | null;
          includedTypes?: string[] | null;
          locationRestriction?:
            | google.maps.Circle
            | google.maps.CircleLiteral
            | null;
          maxResultCount?: number | null;
          rankPreference?: google.maps.places.SearchNearbyRankPreference | null;

          // html-attribute versions
          'excluded-primary-types'?: string;
          'excluded-types'?: string;
          'included-primary-types'?: string;
          'included-types'?: string;
          'max-result-count'?: string | number;
          'rank-preference'?: string;
        },
        google.maps.places.PlaceNearbySearchRequestElement
      >;

      'gmp-place-text-search-request': CustomElement<
        {
          evConnectorTypes?: google.maps.places.EVConnectorType[] | null;
          evMinimumChargingRateKw?: number | null;
          includedType?: string | null;
          isOpenNow?: boolean | null;
          locationBias?: google.maps.places.LocationBias | null;
          locationRestriction?:
            | google.maps.LatLngBounds
            | google.maps.LatLngBoundsLiteral
            | null;
          maxResultCount?: number | null;
          minRating?: number | null;
          priceLevels?: google.maps.places.PriceLevel[] | null;
          rankPreference?: google.maps.places.SearchByTextRankPreference | null;
          textQuery?: string | null;
          useStrictTypeFiltering?: boolean | null;

          // html-attribute versions
          'ev-connector-types'?: string;
          'ev-minimum-charging-rate-kw'?: string | number;
          'included-type'?: string;
          'is-open-now'?: string | boolean;
          'location-bias'?: string;
          'location-restriction'?: string;
          'max-result-count'?: string | number;
          'min-rating'?: string | number;
          'price-levels'?: string;
          'rank-preference'?: string;
          'use-strict-type-filtering'?: string | boolean;
        },
        google.maps.places.PlaceTextSearchRequestElement
      >;

      // ====================================================
      // ======== Place Widget Content Customization ========
      // ====================================================

      'gmp-place-content-config': CustomElement<
        NoAttributes,
        google.maps.places.PlaceContentConfigElement
      >;

      'gmp-place-all-content': CustomElement<
        NoChildren,
        google.maps.places.PlaceAllContentElement
      >;

      'gmp-place-standard-content': CustomElement<
        NoChildren,
        google.maps.places.PlaceStandardContentElement
      >;

      'gmp-place-media': CustomElement<
        {
          lightboxPreferred?: boolean | null;
          preferredSize?: google.maps.places.MediaSize | null;

          // html-attribute versions
          'lightbox-preferred'?: string | boolean;
          'preferred-size'?: string;
        },
        google.maps.places.PlaceMediaElement
      >;

      'gmp-place-address': CustomElement<
        NoChildren,
        google.maps.places.PlaceAddressElement
      >;

      'gmp-place-rating': CustomElement<
        NoChildren,
        google.maps.places.PlaceRatingElement
      >;

      'gmp-place-type': CustomElement<
        NoChildren,
        google.maps.places.PlaceTypeElement
      >;

      'gmp-place-price': CustomElement<
        NoChildren,
        google.maps.places.PlacePriceElement
      >;

      'gmp-place-accessible-entrance-icon': CustomElement<
        NoChildren,
        google.maps.places.PlaceAccessibleEntranceIconElement
      >;

      'gmp-place-open-now-status': CustomElement<
        NoChildren,
        google.maps.places.PlaceOpenNowStatusElement
      >;

      'gmp-place-reviews': CustomElement<
        NoChildren,
        google.maps.places.PlaceReviewsElement
      >;

      'gmp-place-summary': CustomElement<
        NoChildren,
        google.maps.places.PlaceSummaryElement
      >;

      'gmp-place-feature-list': CustomElement<
        NoChildren,
        google.maps.places.PlaceFeatureListElement
      >;

      'gmp-place-opening-hours': CustomElement<
        NoChildren,
        google.maps.places.PlaceOpeningHoursElement
      >;

      'gmp-place-phone-number': CustomElement<
        NoChildren,
        google.maps.places.PlacePhoneNumberElement
      >;

      'gmp-place-plus-code': CustomElement<
        NoChildren,
        google.maps.places.PlacePlusCodeElement
      >;

      'gmp-place-type-specific-highlights': CustomElement<
        NoChildren,
        google.maps.places.PlaceTypeSpecificHighlightsElement
      >;

      'gmp-place-website': CustomElement<
        NoChildren,
        google.maps.places.PlaceWebsiteElement
      >;

      'gmp-place-attribution': CustomElement<
        {
          darkSchemeColor?: google.maps.places.AttributionColor | null;
          lightSchemeColor?: google.maps.places.AttributionColor | null;

          // html-attribute versions
          'dark-scheme-color'?: string;
          'light-scheme-color'?: string;
        },
        google.maps.places.PlaceAttributionElement
      >;
    }
  }
}

declare module 'react' {
  namespace JSX {
    interface IntrinsicElements {
      'gmp-air-quality': CustomElement<
        {
          location?:
            | google.maps.LatLng
            | google.maps.LatLngLiteral
            | google.maps.LatLngAltitude
            | google.maps.LatLngAltitudeLiteral
            | string
            | null;

          requestedLanguage?: string | null;

          // html-attribute versions
          'requested-language'?: string;
        },
        google.maps.airQuality.AirQualityElement
      >;
    }
  }
}

declare module 'react' {
  namespace JSX {
    interface IntrinsicElements {
      'gmp-elevation': CustomElement<
        {
          path?: Array<
            | google.maps.LatLng
            | google.maps.LatLngLiteral
            | google.maps.LatLngAltitude
            | google.maps.LatLngAltitudeLiteral
          > | null;
          unitSystem?: google.maps.UnitSystem | null;

          // html-attribute versions
          'unit-system'?: string;

          // emits 'gmp-requesterror' and 'gmp-load' events
        },
        google.maps.elevation.ElevationElement
      >;
    }
  }
}

declare const VERSION = "__PACKAGE_VERSION__";

interface AdvancedMarkerContextValue {
    marker: google.maps.marker.AdvancedMarkerElement;
}
/**
 * Copy of the `google.maps.CollisionBehavior` constants.
 * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.
 */
declare const CollisionBehavior: {
    readonly REQUIRED: "REQUIRED";
    readonly REQUIRED_AND_HIDES_OPTIONAL: "REQUIRED_AND_HIDES_OPTIONAL";
    readonly OPTIONAL_AND_HIDES_LOWER_PRIORITY: "OPTIONAL_AND_HIDES_LOWER_PRIORITY";
};
type CollisionBehavior = (typeof CollisionBehavior)[keyof typeof CollisionBehavior];
declare const AdvancedMarkerContext: React.Context<AdvancedMarkerContextValue | null>;
/**
 * @deprecated Using `anchorPosition` is deprecated.
 *   Use `anchorLeft` and `anchorTop` instead.
 */
declare const AdvancedMarkerAnchorPoint: {
    readonly TOP_LEFT: readonly ["0%", "0%"];
    readonly TOP_CENTER: readonly ["50%", "0%"];
    readonly TOP: readonly ["50%", "0%"];
    readonly TOP_RIGHT: readonly ["100%", "0%"];
    readonly LEFT_CENTER: readonly ["0%", "50%"];
    readonly LEFT_TOP: readonly ["0%", "0%"];
    readonly LEFT: readonly ["0%", "50%"];
    readonly LEFT_BOTTOM: readonly ["0%", "100%"];
    readonly RIGHT_TOP: readonly ["100%", "0%"];
    readonly RIGHT: readonly ["100%", "50%"];
    readonly RIGHT_CENTER: readonly ["100%", "50%"];
    readonly RIGHT_BOTTOM: readonly ["100%", "100%"];
    readonly BOTTOM_LEFT: readonly ["0%", "100%"];
    readonly BOTTOM_CENTER: readonly ["50%", "100%"];
    readonly BOTTOM: readonly ["50%", "100%"];
    readonly BOTTOM_RIGHT: readonly ["100%", "100%"];
    readonly CENTER: readonly ["50%", "50%"];
};
type AdvancedMarkerAnchorPoint = (typeof AdvancedMarkerAnchorPoint)[keyof typeof AdvancedMarkerAnchorPoint];
type AdvancedMarkerEventProps = {
    onClick?: (e: google.maps.MapMouseEvent) => void;
    onMouseEnter?: (e: google.maps.MapMouseEvent['domEvent']) => void;
    onMouseLeave?: (e: google.maps.MapMouseEvent['domEvent']) => void;
    onDrag?: (e: google.maps.MapMouseEvent) => void;
    onDragStart?: (e: google.maps.MapMouseEvent) => void;
    onDragEnd?: (e: google.maps.MapMouseEvent) => void;
};
type AdvancedMarkerProps = PropsWithChildren<Omit<google.maps.marker.AdvancedMarkerElementOptions, 'gmpDraggable' | 'gmpClickable' | 'content' | 'map' | 'collisionBehavior'> & AdvancedMarkerEventProps & {
    draggable?: boolean;
    clickable?: boolean;
    collisionBehavior?: CollisionBehavior;
    /**
     * @deprecated Use `anchorLeft` and `anchorTop` instead.
     *
     * The anchor point for the Advanced Marker.
     * Either use one of the predefined anchor point from the "AdvancedMarkerAnchorPoint" export
     * or provide a string tuple in the form of ["xPosition", "yPosition"].
     * The position is measured from the top-left corner and
     * can be anything that can be consumed by a CSS translate() function.
     * For example in percent ("50%") or in pixels ("20px").
     */
    anchorPoint?: AdvancedMarkerAnchorPoint | [string, string];
    /**
     * A CSS length-percentage value which is used to offset the anchor point of the marker from the top left corner of the marker. This is useful when using a visual which has an anchor point that is different than the typical bottom center point of the default marker. The default value is "-%50".
     */
    anchorLeft?: string;
    /**
     * A CSS length-percentage value which is used to offset the anchor point of the marker from the top left corner of the marker. This is useful when using a visual which has an anchor point that is different than the typical bottom center point of the default marker. The default value is "-%100".
     */
    anchorTop?: string;
    /**
     * A className for the content element.
     * (can only be used with HTML Marker content)
     */
    className?: string;
    /**
     * Additional styles to apply to the content element.
     */
    style?: CSSProperties;
}>;
declare const AdvancedMarker: React.ForwardRefExoticComponent<Omit<google.maps.marker.AdvancedMarkerElementOptions, "gmpDraggable" | "gmpClickable" | "content" | "map" | "collisionBehavior"> & AdvancedMarkerEventProps & {
    draggable?: boolean;
    clickable?: boolean;
    collisionBehavior?: CollisionBehavior;
    /**
     * @deprecated Use `anchorLeft` and `anchorTop` instead.
     *
     * The anchor point for the Advanced Marker.
     * Either use one of the predefined anchor point from the "AdvancedMarkerAnchorPoint" export
     * or provide a string tuple in the form of ["xPosition", "yPosition"].
     * The position is measured from the top-left corner and
     * can be anything that can be consumed by a CSS translate() function.
     * For example in percent ("50%") or in pixels ("20px").
     */
    anchorPoint?: AdvancedMarkerAnchorPoint | [string, string];
    /**
     * A CSS length-percentage value which is used to offset the anchor point of the marker from the top left corner of the marker. This is useful when using a visual which has an anchor point that is different than the typical bottom center point of the default marker. The default value is "-%50".
     */
    anchorLeft?: string;
    /**
     * A CSS length-percentage value which is used to offset the anchor point of the marker from the top left corner of the marker. This is useful when using a visual which has an anchor point that is different than the typical bottom center point of the default marker. The default value is "-%100".
     */
    anchorTop?: string;
    /**
     * A className for the content element.
     * (can only be used with HTML Marker content)
     */
    className?: string;
    /**
     * Additional styles to apply to the content element.
     */
    style?: CSSProperties;
} & {
    children?: React.ReactNode | undefined;
} & React.RefAttributes<google.maps.marker.AdvancedMarkerElement>>;
declare function useAdvancedMarkerRef(): readonly [(m: AdvancedMarkerRef | null) => void, google.maps.marker.AdvancedMarkerElement | null];
declare function isAdvancedMarker(marker: google.maps.Marker | google.maps.marker.AdvancedMarkerElement): marker is google.maps.marker.AdvancedMarkerElement;
type CustomMarkerContent = HTMLDivElement | null;
type AdvancedMarkerRef = google.maps.marker.AdvancedMarkerElement | null;

declare const APILoadingStatus: {
    readonly NOT_LOADED: "NOT_LOADED";
    readonly LOADING: "LOADING";
    readonly LOADED: "LOADED";
    readonly FAILED: "FAILED";
    readonly AUTH_FAILURE: "AUTH_FAILURE";
};
type APILoadingStatus = (typeof APILoadingStatus)[keyof typeof APILoadingStatus];

type ImportLibraryFunction = typeof google.maps.importLibrary;
type GoogleMapsLibrary = Awaited<ReturnType<ImportLibraryFunction>>;
type LoadedLibraries = {
    [name: string]: GoogleMapsLibrary;
};
interface APIProviderContextValue {
    status: APILoadingStatus;
    loadedLibraries: LoadedLibraries;
    importLibrary: typeof google.maps.importLibrary;
    mapInstances: Record<string, google.maps.Map>;
    addMapInstance: (map: google.maps.Map, id?: string) => void;
    removeMapInstance: (id?: string) => void;
    clearMapInstances: () => void;
    internalUsageAttributionIds: string[] | null;
}
declare const APIProviderContext: React.Context<APIProviderContextValue | null>;
type APIProviderProps = PropsWithChildren<{
    /**
     * apiKey must be provided to load the Google Maps JavaScript API. To create an API key, see: https://developers.google.com/maps/documentation/javascript/get-api-key
     * Part of:
     */
    apiKey: string;
    /**
     * A custom id to reference the script tag can be provided. The default is set to 'google-maps-api'
     * @default 'google-maps-api'
     */
    libraries?: Array<string>;
    /**
     * A specific version of the Google Maps JavaScript API can be used.
     * Read more about versioning: https://developers.google.com/maps/documentation/javascript/versions
     * Part of: https://developers.google.com/maps/documentation/javascript/url-params
     */
    version?: string;
    /**
     * Sets the map to a specific region.
     * Read more about localizing the Map: https://developers.google.com/maps/documentation/javascript/localization
     * Part of: https://developers.google.com/maps/documentation/javascript/url-params
     */
    region?: string;
    /**
     * Use a specific language for the map.
     * Read more about localizing the Map: https://developers.google.com/maps/documentation/javascript/localization
     * Part of: https://developers.google.com/maps/documentation/javascript/url-params
     */
    language?: string;
    /**
     * auth_referrer_policy can be set to 'origin'.
     * Part of: https://developers.google.com/maps/documentation/javascript/url-params
     */
    authReferrerPolicy?: string;
    /**
     * To track usage of Google Maps JavaScript API via numeric channels.
     * The only acceptable channel values are numbers from 0-999.
     * Read more in the
     * [documentation](https://developers.google.com/maps/reporting-and-monitoring/reporting#usage-tracking-per-channel)
     */
    channel?: number;
    /**
     * To understand usage and ways to improve our solutions, Google includes the
     * `solution_channel` query parameter in API calls to gather information about
     * code usage. You may opt out at any time by setting this attribute to an
     * empty string. Read more in the
     * [documentation](https://developers.google.com/maps/reporting-and-monitoring/reporting#solutions-usage).
     */
    solutionChannel?: string;
    /**
     * To help Google understand which libraries and samples are helpful to developers, such as usage of this library.
     * To opt out of sending the usage attribution ID, use this boolean prop. Read more in the
     * [documentation](https://developers.google.com/maps/documentation/javascript/reference/map#MapOptions.internalUsageAttributionIds).
     */
    disableUsageAttribution?: boolean;
    /**
     * A function that can be used to execute code after the Google Maps JavaScript API has been loaded.
     */
    onLoad?: () => void;
    /**
     * A function that will be called if there was an error when loading the Google Maps JavaScript API.
     */
    onError?: (error: unknown) => void;
}>;
/**
 * Component to wrap the components from this library and load the Google Maps JavaScript API
 */
declare const APIProvider: FunctionComponent<APIProviderProps>;

type InfoWindowProps = Omit<google.maps.InfoWindowOptions, 'headerContent' | 'content' | 'pixelOffset'> & {
    style?: CSSProperties;
    className?: string;
    anchor?: google.maps.Marker | google.maps.marker.AdvancedMarkerElement | null;
    pixelOffset?: [number, number];
    shouldFocus?: boolean;
    onClose?: () => void;
    onCloseClick?: () => void;
    headerContent?: ReactNode;
};
/**
 * Component to render an Info Window with the Maps JavaScript API
 */
declare const InfoWindow: FunctionComponent<PropsWithChildren<InfoWindowProps>>;

/**
 * Handlers for all events that could be emitted by map-instances.
 */
type MapEventProps = Partial<{
    onBoundsChanged: (event: MapCameraChangedEvent) => void;
    onCenterChanged: (event: MapCameraChangedEvent) => void;
    onHeadingChanged: (event: MapCameraChangedEvent) => void;
    onTiltChanged: (event: MapCameraChangedEvent) => void;
    onZoomChanged: (event: MapCameraChangedEvent) => void;
    onCameraChanged: (event: MapCameraChangedEvent) => void;
    onClick: (event: MapMouseEvent) => void;
    onDblclick: (event: MapMouseEvent) => void;
    onContextmenu: (event: MapMouseEvent) => void;
    onMousemove: (event: MapMouseEvent) => void;
    onMouseover: (event: MapMouseEvent) => void;
    onMouseout: (event: MapMouseEvent) => void;
    onDrag: (event: MapEvent) => void;
    onDragend: (event: MapEvent) => void;
    onDragstart: (event: MapEvent) => void;
    onTilesLoaded: (event: MapEvent) => void;
    onIdle: (event: MapEvent) => void;
    onProjectionChanged: (event: MapEvent) => void;
    onIsFractionalZoomEnabledChanged: (event: MapEvent) => void;
    onMapCapabilitiesChanged: (event: MapEvent) => void;
    onMapTypeIdChanged: (event: MapEvent) => void;
    onRenderingTypeChanged: (event: MapEvent) => void;
}>;
type MapEvent<T = unknown> = {
    type: string;
    map: google.maps.Map;
    detail: T;
    stoppable: boolean;
    stop: () => void;
    domEvent?: MouseEvent | TouchEvent | PointerEvent | KeyboardEvent | Event;
};
type MapMouseEvent = MapEvent<{
    latLng: google.maps.LatLngLiteral | null;
    placeId: string | null;
}>;
type MapCameraChangedEvent = MapEvent<{
    center: google.maps.LatLngLiteral;
    bounds: google.maps.LatLngBoundsLiteral;
    zoom: number;
    heading: number;
    tilt: number;
}>;

type DeckGlCompatProps = {
    /**
     * Viewport from deck.gl
     */
    viewport?: unknown;
    /**
     * View state from deck.gl
     */
    viewState?: Record<string, unknown>;
    /**
     * Initial View State from deck.gl
     */
    initialViewState?: Record<string, unknown>;
};

interface GoogleMapsContextValue {
    map: google.maps.Map | null;
}
declare const GoogleMapsContext: React.Context<GoogleMapsContextValue | null>;

type MapCameraProps = {
    center: google.maps.LatLngLiteral;
    zoom: number;
    heading?: number;
    tilt?: number;
};
declare const ColorScheme: {
    readonly DARK: "DARK";
    readonly LIGHT: "LIGHT";
    readonly FOLLOW_SYSTEM: "FOLLOW_SYSTEM";
};
type ColorScheme = (typeof ColorScheme)[keyof typeof ColorScheme];
declare const RenderingType: {
    readonly VECTOR: "VECTOR";
    readonly RASTER: "RASTER";
    readonly UNINITIALIZED: "UNINITIALIZED";
};
type RenderingType = (typeof RenderingType)[keyof typeof RenderingType];
/**
 * Props for the Map Component
 */
type MapProps = PropsWithChildren<Omit<google.maps.MapOptions, 'renderingType' | 'colorScheme'> & MapEventProps & DeckGlCompatProps & {
    /**
     * An id for the map, this is required when multiple maps are present
     * in the same APIProvider context.
     */
    id?: string;
    /**
     * Additional style rules to apply to the map dom-element.
     */
    style?: CSSProperties;
    /**
     * Additional css class-name to apply to the element containing the map.
     */
    className?: string;
    /**
     * The color-scheme to use for the map.
     */
    colorScheme?: ColorScheme;
    /**
     * The rendering-type to be used.
     */
    renderingType?: RenderingType;
    /**
     * Indicates that the map will be controlled externally. Disables all controls provided by the map itself.
     */
    controlled?: boolean;
    /**
     * Enable caching of map-instances created by this component.
     */
    reuseMaps?: boolean;
    defaultCenter?: google.maps.LatLngLiteral;
    defaultZoom?: number;
    defaultHeading?: number;
    defaultTilt?: number;
    /**
     * Alternative way to specify the default camera props as a geographic region that should be fully visible
     */
    defaultBounds?: google.maps.LatLngBoundsLiteral & {
        padding?: number | google.maps.Padding;
    };
}>;
declare const Map: FunctionComponent<MapProps>;

type StaticMapsLocation = google.maps.LatLngLiteral | string;
type StaticMapsMarker = {
    location: StaticMapsLocation;
    color?: string;
    size?: 'tiny' | 'mid' | 'small';
    label?: string;
    icon?: string;
    anchor?: string;
    scale?: 1 | 2 | 4;
};
type StaticMapsPath = {
    coordinates: Array<StaticMapsLocation> | string;
    weight?: number;
    color?: string;
    fillcolor?: string;
    geodesic?: boolean;
};
type StaticMapsApiOptions = {
    apiKey: string;
    width: number;
    height: number;
    center?: StaticMapsLocation;
    zoom?: number;
    scale?: number;
    format?: 'png' | 'png8' | 'png32' | 'gif' | 'jpg' | 'jpg-baseline';
    mapType?: google.maps.MapTypeId;
    language?: string;
    region?: string;
    mapId?: string;
    markers?: Array<StaticMapsMarker>;
    paths?: Array<StaticMapsPath>;
    visible?: Array<StaticMapsLocation>;
    style?: google.maps.MapTypeStyle[];
};

/**
 * Creates a URL for the Google Static Maps API with the specified parameters.
 *
 * @param {Object} options - The configuration options for the static map
 * @param {string} options.apiKey - Your Google Maps API key (required)
 * @param {number} options.width - The width of the map image in pixels (required)
 * @param {number} options.height - The height of the map image in pixels (required)
 * @param {StaticMapsLocation} [options.center] - The center point of the map (lat/lng or address).
 *  Required if no markers or paths or "visible locations" are provided.
 * @param {number} [options.zoom] - The zoom level of the map. Required if no markers or paths or "visible locations" are provided.
 * @param {1|2|4} [options.scale] - The resolution of the map (1, 2, or 4)
 * @param {string} [options.format] - The image format (png, png8, png32, gif, jpg, jpg-baseline)
 * @param {string} [options.mapType] - The type of map (roadmap, satellite, terrain, hybrid)
 * @param {string} [options.language] - The language of the map labels
 * @param {string} [options.region] - The region code for the map
 * @param {string} [options.map_id] - The Cloud-based map style ID
 * @param {StaticMapsMarker[]} [options.markers=[]] - Array of markers to display on the map
 * @param {StaticMapsPath[]} [options.paths=[]] - Array of paths to display on the map
 * @param {StaticMapsLocation[]} [options.visible=[]] - Array of locations that should be visible on the map
 * @param {MapTypeStyle[]} [options.style=[]] - Array of style objects to customize the map appearance
 *
 * @returns {string} The complete Google Static Maps API URL
 *
 * @throws {Error} If API key is not provided
 * @throws {Error} If width or height is not provided
 *
 * @example
 * const url = createStaticMapsUrl({
 *   apiKey: 'YOUR_API_KEY',
 *   width: 600,
 *   height: 400,
 *   center: { lat: 40.714728, lng: -73.998672 },
 *   zoom: 12,
 *   markers: [
 *     {
 *       location: { lat: 40.714728, lng: -73.998672 },
 *       color: 'red',
 *       label: 'A'
 *     }
 *   ],
 *   paths: [
 *     {
 *       coordinates: [
 *         { lat: 40.714728, lng: -73.998672 },
 *         { lat: 40.719728, lng: -73.991672 }
 *       ],
 *       color: '0x0000ff',
 *       weight: 5
 *     }
 *   ],
 *   style: [
 *     {
 *       featureType: 'road',
 *       elementType: 'geometry',
 *       stylers: [{color: '#00ff00'}]
 *     }
 *   ]
 * });
 *
 * // Results in URL similar to:
 * // https://maps.googleapis.com/maps/api/staticmap?key=YOUR_API_KEY
 * // &size=600x400
 * // &center=40.714728,-73.998672&zoom=12
 * // &markers=color:red|label:A|40.714728,-73.998672
 * // &path=color:0x0000ff|weight:5|40.714728,-73.998672|40.719728,-73.991672
 * // &style=feature:road|element:geometry|color:0x00ff00
 */
declare function createStaticMapsUrl({ apiKey, width, height, center, zoom, scale, format, mapType, language, region, mapId, markers, paths, visible, style }: StaticMapsApiOptions): string;

/**
 * Props for the StaticMap component
 */
type StaticMapProps = {
    url: string;
    className?: string;
};
declare const StaticMap: (props: StaticMapProps) => React.JSX.Element;

type MapControlProps = PropsWithChildren<{
    position: ControlPosition;
}>;
/**
 * Copy of the `google.maps.ControlPosition` constants.
 * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.
 */
declare const ControlPosition: {
    readonly TOP_LEFT: 1;
    readonly TOP_CENTER: 2;
    readonly TOP: 2;
    readonly TOP_RIGHT: 3;
    readonly LEFT_CENTER: 4;
    readonly LEFT_TOP: 5;
    readonly LEFT: 5;
    readonly LEFT_BOTTOM: 6;
    readonly RIGHT_TOP: 7;
    readonly RIGHT: 7;
    readonly RIGHT_CENTER: 8;
    readonly RIGHT_BOTTOM: 9;
    readonly BOTTOM_LEFT: 10;
    readonly BOTTOM_CENTER: 11;
    readonly BOTTOM: 11;
    readonly BOTTOM_RIGHT: 12;
    readonly CENTER: 13;
    readonly BLOCK_START_INLINE_START: 14;
    readonly BLOCK_START_INLINE_CENTER: 15;
    readonly BLOCK_START_INLINE_END: 16;
    readonly INLINE_START_BLOCK_CENTER: 17;
    readonly INLINE_START_BLOCK_START: 18;
    readonly INLINE_START_BLOCK_END: 19;
    readonly INLINE_END_BLOCK_START: 20;
    readonly INLINE_END_BLOCK_CENTER: 21;
    readonly INLINE_END_BLOCK_END: 22;
    readonly BLOCK_END_INLINE_START: 23;
    readonly BLOCK_END_INLINE_CENTER: 24;
    readonly BLOCK_END_INLINE_END: 25;
};
type ControlPosition = (typeof ControlPosition)[keyof typeof ControlPosition];
declare const MapControl: FunctionComponent<MapControlProps>;

type MarkerEventProps = {
    onClick?: (e: google.maps.MapMouseEvent) => void;
    onDrag?: (e: google.maps.MapMouseEvent) => void;
    onDragStart?: (e: google.maps.MapMouseEvent) => void;
    onDragEnd?: (e: google.maps.MapMouseEvent) => void;
    onMouseOver?: (e: google.maps.MapMouseEvent) => void;
    onMouseOut?: (e: google.maps.MapMouseEvent) => void;
};
type MarkerProps = Omit<google.maps.MarkerOptions, 'map'> & MarkerEventProps;
type MarkerRef = Ref<google.maps.Marker | null>;
/**
 * Component to render a marker on a map
 */
declare const Marker: React.ForwardRefExoticComponent<Omit<google.maps.MarkerOptions, "map"> & MarkerEventProps & React.RefAttributes<google.maps.Marker>>;
declare function useMarkerRef(): readonly [(m: google.maps.Marker | null) => void, google.maps.Marker | null];

/**
 * Props for the Pin component
 */
type PinProps = PropsWithChildren<google.maps.marker.PinElementOptions>;
/**
 * Component to configure the appearance of an AdvancedMarker
 */
declare const Pin: FunctionComponent<PinProps>;

declare function useApiLoadingStatus(): APILoadingStatus;

/**
 * Hook to check if the Maps JavaScript API is loaded
 */
declare function useApiIsLoaded(): boolean;

interface ApiLibraries {
    core: google.maps.CoreLibrary;
    maps: google.maps.MapsLibrary;
    places: google.maps.PlacesLibrary;
    geocoding: google.maps.GeocodingLibrary;
    routes: google.maps.RoutesLibrary;
    marker: google.maps.MarkerLibrary;
    geometry: google.maps.GeometryLibrary;
    elevation: google.maps.ElevationLibrary;
    streetView: google.maps.StreetViewLibrary;
    journeySharing: google.maps.JourneySharingLibrary;
    drawing: google.maps.DrawingLibrary;
    visualization: google.maps.VisualizationLibrary;
    maps3d: google.maps.Maps3DLibrary;
}
declare function useMapsLibrary<K extends keyof ApiLibraries, V extends ApiLibraries[K]>(name: K): V | null;

/**
 * Retrieves a map-instance from the context. This is either an instance
 * identified by id or the parent map instance if no id is specified.
 * Returns null if neither can be found.
 */
declare const useMap: (id?: string | null) => google.maps.Map | null;

declare function isLatLngLiteral(obj: unknown): obj is google.maps.LatLngLiteral;
declare function latLngEquals(a: google.maps.LatLngLiteral | google.maps.LatLng | undefined | null, b: google.maps.LatLngLiteral | google.maps.LatLng | undefined | null): boolean;
declare function toLatLngLiteral(obj: google.maps.LatLngLiteral | google.maps.LatLng): google.maps.LatLngLiteral;

/**
 * Function to limit the tilt range of the Google map when updating the view state
 */
declare const limitTiltRange: ({ viewState }: any) => any;

export { APILoadingStatus, APIProvider, APIProviderContext, AdvancedMarker, AdvancedMarkerAnchorPoint, AdvancedMarkerContext, CollisionBehavior, ColorScheme, ControlPosition, GoogleMapsContext, InfoWindow, Map, MapControl, Marker, Pin, RenderingType, StaticMap, VERSION, createStaticMapsUrl, isAdvancedMarker, isLatLngLiteral, latLngEquals, limitTiltRange, toLatLngLiteral, useAdvancedMarkerRef, useApiIsLoaded, useApiLoadingStatus, useMap, useMapsLibrary, useMarkerRef };
export type { APIProviderContextValue, APIProviderProps, AdvancedMarkerContextValue, AdvancedMarkerProps, AdvancedMarkerRef, CustomMarkerContent, GoogleMapsContextValue, InfoWindowProps, Map3DProps, MapCameraChangedEvent, MapCameraProps, MapEvent, MapEventProps, MapMouseEvent, MapProps, Marker3DProps, MarkerProps, MarkerRef, Model3DProps, NoAttributes, NoChildren, PinProps, Polygon3DProps, Polyline3DProps, PopoverProps, StaticMapProps, StaticMapsApiOptions, StaticMapsLocation, StaticMapsMarker, StaticMapsPath };
